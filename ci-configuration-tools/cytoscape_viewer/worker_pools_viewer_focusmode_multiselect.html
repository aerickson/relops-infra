<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Worker Pools Graph Viewer (Class Styling + Filters)</title>
  <script src="https://unpkg.com/cytoscape@3.25.0/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/cytoscape-tidytree@0.2.0/dist/cytoscape-tidytree.min.js"></script>
<style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #sidebar {
      width: 250px;
      background: #f4f4f4;
      border-right: 1px solid #ccc;
      padding: 15px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    #cy {
      flex-grow: 1;
      height: 100%;
    }
    select, input[type="text"], button {
      width: 100%;
      margin: 8px 0;
      padding: 5px;
      box-sizing: border-box;
    }
    h2 {
      margin-top: 0;
    }
    .legend-group {
      margin: 10px 0;
    }
    label {
      display: block;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Controls</h2>
    <label for="layout">Layout:</label>
    <select id="layout">
      <option value="initial">Initial</option>
      <option value="tidytree">Tidytree</option>
      <option value="cose">Cose</option>
      <option value="grid">Grid</option>
      <option value="circle">Circle</option>
      <option value="breadthfirst">Breadthfirst</option>
      <option value="concentric">Concentric</option>
      <option value="random">Random</option>
      <!-- <option value="cise">Cise</option> -->
      <!-- <option value="cose-bilkent">Cose-Bilkent</option>
      <option value="cola">Cola</option>
      <option value="euler">Euler</option>
      <option value="spread">Spread</option>
      <option value="dagre">Dagre</option>
      <option value="klay">Klay</option> -->
    </select>
    <button onclick="runLayout()">Apply Layout</button>

    <label for="search">Search Node:</label>
    <input type="text" id="search" placeholder="Enter label or ID">
    <button onclick="searchNode()">Search</button>
    <button onclick="fitGraph()">Fit View</button>
    <button onclick="clearHighlights()">Clear Highlights</button>
<button onclick="showOnlyLinked()">Show Only Linked</button>
<button onclick="showAll()">Show All Nodes</button>

    <div id="selected-info" style="margin: 10px 0; padding: 8px; background: #e9e9e9; border-radius: 4px;">
      <strong>Selected Nodes:</strong>
      <div id="selected-count">0</div>
      <ul id="selected-list" style="margin:0; padding-left: 18px;"></ul>
    </div>

    <div class="legend-group">
      <h3>Node Type Filter</h3>
      <label><input type="checkbox" class="typeFilter" value="taskNode" checked> taskNode</label>
      <label><input type="checkbox" class="typeFilter" value="poolNode" checked> poolNode</label>
      <label><input type="checkbox" class="typeFilter" value="hwPoolNode" checked> hwPoolNode</label>
      <label><input type="checkbox" class="typeFilter" value="aliasNode" checked> aliasNode</label>
      <label><input type="checkbox" class="typeFilter" value="imageNode" checked> imageNode</label>
      <label><input type="checkbox" class="typeFilter" value="l3imageNode" checked> l3imageNode</label>
    </div>
  </div>
  <div id="cy"></div>

  <script>
    var cy;

    let hierarchy = ['taskNode', ['poolNode', 'hwPoolNode'], 'aliasNode', ['imageNode', 'l3imageNode']];

    // Flatten hierarchy and build class-to-level map
    function getClassLevelMap(hierarchy) {
      const map = {};
      let level = 0;
      for (const entry of hierarchy) {
        if (Array.isArray(entry)) {
          for (const cls of entry) {
            map[cls] = level;
          }
        } else {
          map[entry] = level;
        }
        level++;
      }
      return map;
    }
    const classLevelMap = getClassLevelMap(hierarchy);

    function showOnlyLinked() {
      const selected = cy.nodes(':selected');
      if (!selected || selected.length === 0) return;

      function getNodeClass(node) {
        for (const cls in classLevelMap) {
          if (node.hasClass(cls)) return cls;
        }
        return null;
      }

      function getNodeLevel(node) {
        const cls = getNodeClass(node);
        return classLevelMap[cls];
      }

      let visited = new Set();
      let result = cy.collection();

      // For each selected node, do a Â±n level wave expansion
      selected.forEach(startNode => {
        const baseLevel = getNodeLevel(startNode);
        if (baseLevel === undefined) return;
        visited.add(startNode.id());
        result = result.union(startNode);

        let wave = 1;
        let currentFrontier = [startNode];
        let foundAny = true;
        while (foundAny) {
          foundAny = false;
          let nextFrontier = [];
          currentFrontier.forEach(node => {
            node.connectedEdges().forEach(edge => {
              let other = edge.source().id() === node.id() ? edge.target() : edge.source();
              if (visited.has(other.id())) return;
              const otherLevel = getNodeLevel(other);
              if (otherLevel === baseLevel + wave || otherLevel === baseLevel - wave) {
                result = result.union(other).union(edge);
                nextFrontier.push(other);
                visited.add(other.id());
                foundAny = true;
              }
            });
          });
          currentFrontier = nextFrontier;
          wave++;
        }
      });

      cy.elements().forEach(el => {
        el.style('display', result.contains(el) ? 'element' : 'none');
      });
    }

    function showAll() {
      if (!cy) return;
      // Get active types from checkboxes
      const activeTypes = Array.from(document.querySelectorAll('.typeFilter:checked'))
        .map(cb => cb.value);

      // Show/hide nodes based on type filter
      cy.nodes().forEach(n => {
        n.style('display', activeTypes.includes(n.data('type')) ? 'element' : 'none');
      });

      // Show/hide edges: only show if both source and target are visible
      cy.edges().forEach(e => {
        const srcVisible = e.source().style('display') !== 'none';
        const tgtVisible = e.target().style('display') !== 'none';
        e.style('display', (srcVisible && tgtVisible) ? 'element' : 'none');
      });
    }

    var cy;

    // Utility to update selected node info in sidebar
    function updateSelectedInfo() {
      if (!cy) return;
      const selected = cy.nodes(':selected');
      document.getElementById('selected-count').textContent = selected.length;
      const list = document.getElementById('selected-list');
      list.innerHTML = '';
      selected.forEach(n => {
        const label = n.data('label') || n.id();
        const li = document.createElement('li');
        li.textContent = label;
        list.appendChild(li);
      });
    }

    fetch('worker_pools_images.cyto.json')
      .then(response => response.json())
      .then(raw => {
        const elements = raw.elements || raw;
        
        // Assign Y-row positions by class using preset layout
        const classGroups = {};
        let xSpacing = 150;
        let ySpacing = 100;

        elements.forEach((el) => {
          if (el.data && el.data.id && el.classes) {
            const cls = el.classes || 'unknown';
            if (!classGroups[cls]) classGroups[cls] = [];
            classGroups[cls].push(el);
          }
        });

        let y = 0;
        for (const level of hierarchy) {
          let classesAtLevel = Array.isArray(level) ? level : [level];
          // Find the largest group size for this level to help with centering if needed
          let maxGroupSize = Math.max(...classesAtLevel.map(cls => (classGroups[cls] || []).length));
          let xOffset = 0;
          for (const cls of classesAtLevel) {
            const group = classGroups[cls] || [];
            group.forEach((el, i) => {
              el.position = { x: xOffset + i * xSpacing, y };
              el.data = el.data || {};
              el.data.originalPosition = { x: el.position.x, y: el.position.y };
            });
            xOffset += group.length * xSpacing;
          }
          y += ySpacing;
        }

        // Create Cytoscape with preset positions
        cy = cytoscape({

          container: document.getElementById('cy'),
          elements: elements,
          style: [
            {
              selector: 'node',
              style: {
                'label': function(ele) { return ele.data('label') || ele.id(); },
                'text-valign': 'center',
                'text-halign': 'center',
                'shape': 'roundrectangle',
                'width': 'label',
                'padding': '10px',
                'border-width': 1,
                'border-color': '#333',
                'color': '#000',
                'background-color': '#ccc'
              }
            },
            { selector: '.taskNode', style: { 'background-color': '#dda0dd' } },
            { selector: '.poolNode', style: { 'background-color': '#b6fcd5' } },
            { selector: '.hwPoolNode', style: { 'background-color': '#91c9aa' } },
            { selector: '.aliasNode', style: { 'background-color': '#d0e7ff' } },
            { selector: '.imageNode', style: { 'background-color': '#fff9b1' } },
            { selector: '.l3imageNode', style: { 'background-color': '#ffd6e0' } },
            {
              selector: 'edge',
              style: {
                'width': 1,
                'line-color': '#ccc',
                'target-arrow-color': '#ccc',
                'target-arrow-shape': 'triangle'
              }
            },
            {
              selector: '.highlighted',
              style: {
                'background-color': '#f00',
                'line-color': '#f00',
                'target-arrow-color': '#f00',
                'transition-property': 'background-color, line-color, target-arrow-color',
                'transition-duration': '0.5s'
              }
            }
          ],
          layout: {
            name: 'preset',
            fit: true,
            padding: 50
          }
        });

        cy.on('tap', 'node', function(evt) {
          var node = evt.target;
          var neighborhood = node.closedNeighborhood();
          cy.elements().removeClass('highlighted');
          neighborhood.addClass('highlighted');
        });

        // Also update sidebar on selection changes (e.g. via ctrl+click)
        cy.on('select unselect', 'node', function() {
          updateSelectedInfo();
        });

        // Filter nodes by type
        document.querySelectorAll('.typeFilter').forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            const activeTypes = Array.from(document.querySelectorAll('.typeFilter:checked'))
              .map(cb => cb.value);
            cy.nodes().forEach(n => {
              n.style('display', activeTypes.includes(n.data('type')) ? 'element' : 'none');
            });
          });
        });
      });

    function restoreInitialPositions() {
      cy.nodes().forEach(node => {
        const orig = node.data('originalPosition');
        if (orig) {
          node.position(orig);
        }
      });
    }

    function runLayout() {
      const layoutName = document.getElementById('layout').value;
      if (layoutName === 'initial') {
        restoreInitialPositions();
        cy.layout({ name: 'preset', fit: true, padding: 50 }).run();
      } else {
        cy.layout({ name: layoutName, fit: true, padding: 50 }).run();
      }
    }

    function searchNode() {
      const term = document.getElementById('search').value.toLowerCase();
      if (!term || !cy) return;
      cy.elements().removeClass('highlighted');
      const match = cy.nodes().filter(node =>
        node.data('label').toLowerCase().includes(term) ||
        node.id().toLowerCase().includes(term)
      );
      if (match.length > 0) {
        match.select();
        match.addClass('highlighted');
        cy.center(match);
      }
    }

    // Enable pressing Enter in the search field to trigger search
    document.getElementById('search').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        searchNode();
      }
    });

    function fitGraph() {
      if (cy) cy.fit();
    }

    function clearHighlights() {
      if (cy) {
        cy.elements().removeClass('highlighted');
        cy.elements().unselect();
        updateSelectedInfo();
      }
    }
  </script>
</body>
</html>
